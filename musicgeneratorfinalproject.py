# -*- coding: utf-8 -*-
"""MusicGeneratorFinalProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15xSz1AXtI6Rd5W2eY7PXjqjczmovAMaA
"""

# Commented out IPython magic to ensure Python compatibility.
#@test {"output": "ignore"}
# Downgrading to tensorflow version 1
# %tensorflow_version 1.x

# Print statement stating to inform that the program is installing the needed dependencies
print('Installing dependencies...')
# Actually downloading the dependencies
!apt-get update -qq && apt-get install -qq libfluidsynth1 fluid-soundfont-gm build-essential libasound2-dev libjack-dev
!pip install -qU pyfluidsynth pretty_midi

# Pip downloading Magenta
!pip install -qU magenta

# Hack to allow python to pick up the newly-installed fluidsynth lib. 
# This is only needed for the hosted Colab environment.
# Importing the cytpes.util library
import ctypes.util

orig_ctypes_util_find_library = ctypes.util.find_library
def proxy_find_library(lib):
  if lib == 'fluidsynth':
    return 'libfluidsynth.so.1'
  else:
    return orig_ctypes_util_find_library(lib)
ctypes.util.find_library = proxy_find_library

# Print statement stating to inform that the program is importing libraries
print('Importing libraries and defining some helper functions...')

# Importing Google Colab library with files
from google.colab import files

# Importing Magenta Music library as mm
import magenta.music as mm
# Importing the magenta library
import magenta
# Importing the Tensorflow library
import tensorflow

# Print statement informing user that the program is done downloading
# all libraries and modules
print('ðŸŽ‰ Done!')
# Print statement informing user what version of Magenta is being used
print(magenta.__version__)
# Print statement informing user what version of Tensorflow is being used
print(tensorflow.__version__)

# Importing the Magenta music.protobuf with music_pb2
from magenta.music.protobuf import music_pb2

# First song the AI will generate will be Twinkle Twinkle Little Star
# The variable twinkle_twinkle will be correlated to music_pb2.NoteSequence
# Magenta is centered around NoteSequences which will give it an abstract
# Representation of Twinkle Twinkle Littler Star
twinkle_twinkle = music_pb2.NoteSequence()

# Add the notes to the sequence.
# 14 Notes compsed to make a snippet version of Twinkle Twinkle Little Star
# Each note added has a different pitch
# Each note has a start time, end time, and velocity
# Music note #1
twinkle_twinkle.notes.add(pitch=60, start_time=0.0, end_time=0.5, velocity=80)
# Music note #2
twinkle_twinkle.notes.add(pitch=60, start_time=0.5, end_time=1.0, velocity=80)
# Music note #3
twinkle_twinkle.notes.add(pitch=67, start_time=1.0, end_time=1.5, velocity=80)
# Music note #4
twinkle_twinkle.notes.add(pitch=67, start_time=1.5, end_time=2.0, velocity=80)
# Music note #5
twinkle_twinkle.notes.add(pitch=69, start_time=2.0, end_time=2.5, velocity=80)
# Music note #6
twinkle_twinkle.notes.add(pitch=69, start_time=2.5, end_time=3.0, velocity=80)
# Music note #7
twinkle_twinkle.notes.add(pitch=67, start_time=3.0, end_time=4.0, velocity=80)
# Music note #8
twinkle_twinkle.notes.add(pitch=65, start_time=4.0, end_time=4.5, velocity=80)
# Music note #9
twinkle_twinkle.notes.add(pitch=65, start_time=4.5, end_time=5.0, velocity=80)
# Music note #10
twinkle_twinkle.notes.add(pitch=64, start_time=5.0, end_time=5.5, velocity=80)
# Music note #11
twinkle_twinkle.notes.add(pitch=64, start_time=5.5, end_time=6.0, velocity=80)
# Music note #12
twinkle_twinkle.notes.add(pitch=62, start_time=6.0, end_time=6.5, velocity=80)
# Music note #13
twinkle_twinkle.notes.add(pitch=62, start_time=6.5, end_time=7.0, velocity=80)
# Music note #14
twinkle_twinkle.notes.add(pitch=60, start_time=7.0, end_time=8.0, velocity=80) 

# The total time duration should be about 8 seconds
twinkle_twinkle.total_time = 8

# The tempo of Twinkle Twinkle Little Start will be 60 quarter notes per minute
twinkle_twinkle.tempos.add(qpm=60);

# This is a colab utility method that visualizes the NoteSequence
# For Twinkle Twinkle Little Star.
mm.plot_sequence(twinkle_twinkle)

# This is a colab utility method that plays the NoteSequence.
# For Twinkle Twinkle Little Star.
mm.play_sequence(twinkle_twinkle,synth=mm.fluidsynth)


# First song the AI will generate will be I'm A Little Teapot
# The variable teapot will be correlated to music_pb2.NoteSequence
# Magenta is centered around NoteSequences which will give it an abstract
# Representation of the Teapot song
# Here's another NoteSequence but for Teapot song
teapot = music_pb2.NoteSequence()

# Add the notes to the sequence.
# 9 Notes compsed to make a snippet version of I'm a Little Tea Pot
# Each note added has a different pitch
# Each note has a start time, end time, and velocity
# Music note #1
teapot.notes.add(pitch=69, start_time=0, end_time=0.5, velocity=80)
# Music note #2
teapot.notes.add(pitch=71, start_time=0.5, end_time=1, velocity=80)
# Music note #3
teapot.notes.add(pitch=73, start_time=1, end_time=1.5, velocity=80)
# Music note #4
teapot.notes.add(pitch=74, start_time=1.5, end_time=2, velocity=80)
# Music note #5
teapot.notes.add(pitch=76, start_time=2, end_time=2.5, velocity=80)
# Music note #6
teapot.notes.add(pitch=81, start_time=3, end_time=4, velocity=80)
# Music note #7
teapot.notes.add(pitch=78, start_time=4, end_time=5, velocity=80)
# Music note #8
teapot.notes.add(pitch=81, start_time=5, end_time=6, velocity=80)
# Music note #9
teapot.notes.add(pitch=76, start_time=6, end_time=8, velocity=80)

# The time of the Teapot song should last about 8 seconds
teapot.total_time = 8

# The tempo of Teapot Start will be 60 quarter notes per minute
teapot.tempos.add(qpm=60);

# This is a colab utility method that visualizes the NoteSequence
# For Twinkle Twinkle Little Star.
mm.plot_sequence(teapot)

# This is a colab utility method that plays the NoteSequence.
# For TWinkle Twinkle Little Star.
mm.play_sequence(teapot,synth=mm.synthesize)

# The third song the AI will generate will be drum sounds
# The variable drums will be correlated to music_pb2.NoteSequence
# Magenta is centered around NoteSequences which will give it an abstract
# Representation of the drum sounds
# Here's another NoteSequence but for drum sounds
drums = music_pb2.NoteSequence()

# Add the notes to the sequence.
# 18 Notes composed to make a snippet of drum sounds
# Each note added has a different pitch
# Each note has a start time, end time, and velocity
# Sound note #1
drums.notes.add(pitch=36, start_time=0, end_time=0.125, is_drum=True, instrument=10, velocity=80)
# Sound note #2
drums.notes.add(pitch=38, start_time=0, end_time=0.125, is_drum=True, instrument=10, velocity=80)
# Sound note #3
drums.notes.add(pitch=42, start_time=0, end_time=0.125, is_drum=True, instrument=10, velocity=80)
# Sound note #4
drums.notes.add(pitch=46, start_time=0, end_time=0.125, is_drum=True, instrument=10, velocity=80)
# Sound note #5
drums.notes.add(pitch=42, start_time=0.25, end_time=0.375, is_drum=True, instrument=10, velocity=80)
# Sound note #6
drums.notes.add(pitch=42, start_time=0.375, end_time=0.5, is_drum=True, instrument=10, velocity=80)
# Sound note #7
drums.notes.add(pitch=42, start_time=0.5, end_time=0.625, is_drum=True, instrument=10, velocity=80)
# Sound note #8
drums.notes.add(pitch=50, start_time=0.5, end_time=0.625, is_drum=True, instrument=10, velocity=80)
# Sound note #9
drums.notes.add(pitch=36, start_time=0.75, end_time=0.875, is_drum=True, instrument=10, velocity=80)
# Sound note #10
drums.notes.add(pitch=38, start_time=0.75, end_time=0.875, is_drum=True, instrument=10, velocity=80)
# Sound note #11
drums.notes.add(pitch=42, start_time=0.75, end_time=0.875, is_drum=True, instrument=10, velocity=80)
# Sound note #12
drums.notes.add(pitch=45, start_time=0.75, end_time=0.875, is_drum=True, instrument=10, velocity=80)
# Sound note #13
drums.notes.add(pitch=36, start_time=1, end_time=1.125, is_drum=True, instrument=10, velocity=80)
# Sound note #14
drums.notes.add(pitch=42, start_time=1, end_time=1.125, is_drum=True, instrument=10, velocity=80)
# Sound note #15
drums.notes.add(pitch=46, start_time=1, end_time=1.125, is_drum=True, instrument=10, velocity=80)
# Sound note #16
drums.notes.add(pitch=42, start_time=1.25, end_time=1.375, is_drum=True, instrument=10, velocity=80)
# Sound note #17
drums.notes.add(pitch=48, start_time=1.25, end_time=1.375, is_drum=True, instrument=10, velocity=80)
# Sound note #18
drums.notes.add(pitch=50, start_time=1.25, end_time=1.375, is_drum=True, instrument=10, velocity=80)

# The time of the compiled drum sounds should last about 1.375 seconds
drums.total_time = 1.375

# The tempo of the compiled of drum sounds will be 60 quarter notes per minute
drums.tempos.add(qpm=60)

# This is a colab utility method that visualizes the NoteSequence
# For the compiled drum sounds.
mm.plot_sequence(drums)

# This is a colab utility method that plays the NoteSequence.
# For the compiled drum sounds.
mm.play_sequence(drums,synth=mm.fluidsynth)

# A print statement to inform user that the program is downloading model bundle
print('Downloading model bundle. This will take less than a minute...')
# Downloading the colab utility of the model bundle
mm.notebook_utils.download_bundle('basic_rnn.mag', '/content/')

# Import dependencies.
# Importing Magenta.melody_rnn with Melody_RNN sequence Generator
# Using MelodyRNN which a a Long Short Term Memory langauge model for music notes
from magenta.models.melody_rnn import melody_rnn_sequence_generator
# Importing Magenta.models.shared with sequence generator bundle
from magenta.models.shared import sequence_generator_bundle
# Importing Magenta music.protobuf with generator_pb2
from magenta.music.protobuf import generator_pb2
# Importing Magenta music.protobuf with music_pb2
from magenta.music.protobuf import music_pb2

# Initialize the model.
# Print statement informing user that music is being generated by a MelodyRNN
# which a a Long Short Term Memory langauge model for music notes
print("Initializing Melody RNN...")
# The bundle will be associated with sequence generator bundle and will read
# the file ---> /content/basic_rnn.mag
bundle = sequence_generator_bundle.read_bundle_file('/content/basic_rnn.mag')
# The generator map will be associated with the Melody RNN generator map
generator_map = melody_rnn_sequence_generator.get_generator_map()
# The medlody_rnn will be associated with generator map
melody_rnn = generator_map['basic_rnn'](checkpoint=None, bundle=bundle)
# The music notes created by Melody RNN will be initialized
melody_rnn.initialize()

# Print statement to inform user that this section of code is done proecessing
print('ðŸŽ‰ Done!')

# This will generate new notes depended on the Melody RNN model
# The input sequence will be assoicated to the music notes of
# the song Twinkle Twinkle Little Star
# This can be changed to the Teapot song
input_sequence = twinkle_twinkle 
# Number of sequences
# Change this for shorter or longer sequences
num_steps = 128 
# The temperture of the song composition by the AI through Melody RNN model
# The higher the temperature the more random the sequence.
temperature = 1.0 

# Set the start time to begin on the next step after the last note ends.
last_end_time = (max(n.end_time for n in input_sequence.notes)
                  if input_sequence.notes else 0)
# Gather the tempt from the tempo applied by 
# the Twinkle Twinkle Little Star previously in the code
qpm = input_sequence.tempos[0].qpm 
# The seconder per step being calculated for the 
seconds_per_step = 60.0 / qpm / melody_rnn.steps_per_quarter
# Calculating the duratioin of the modified song
total_seconds = num_steps * seconds_per_step

# Calculating the generator options
generator_options = generator_pb2.GeneratorOptions()
# Generating the temperture in association of generator_options
generator_options.args['temperature'].float_value = temperature
# Generating the modified music model
# Generate the start time of the new created notes
# Generate the end time of the new created notes
# Generate the total time
# Generate the seconds per second with the new notes created
generate_section = generator_options.generate_sections.add(
  start_time=last_end_time + seconds_per_step,
  end_time=total_seconds)

# Ask the model to continue the sequence.
sequence = melody_rnn.generate(input_sequence, generator_options)

# This is a colab utility method that visualizes the NoteSequence
# For the newly modified song.
mm.plot_sequence(sequence)

# This is a colab utility method that plays the NoteSequence.
# For the newly modified song.
mm.play_sequence(sequence, synth=mm.fluidsynth)

# This section of code will be generating music through the Music VAE model
# This will basically fuse the Twinkle Twinkle Little Star song with
# The Teapot song
# Which is a variational autoencoder made up of an encoder and decoder
# Print statement informing user that it is copying checkpoint from GCS
print('Copying checkpoint from GCS. This will take less than a minute...')
# This will download the mel_2bar_big checkpoint. There are more checkpoints that you
# can use with this model, depending on what kind of output you want
# See the list of checkpoints: https://github.com/tensorflow/magenta/tree/master/magenta/models/music_vae#pre-trained-checkpoints
!gsutil -q -m cp -R gs://download.magenta.tensorflow.org/models/music_vae/colab2/checkpoints/mel_2bar_big.ckpt.* /content/

# Import dependencies.
# Importing Magenta models Music VAE and importing configs
from magenta.models.music_vae import configs
# Importing Magents models Music VAE with trained models and importing
# the Trained Model for Music VAE model
from magenta.models.music_vae.trained_model import TrainedModel

# Initialize the model.
# Print statement informing user that the program is initializing the
# Music VAE model 
print("Initializing Music VAE...")
# Creating the Music VAE model with association of the trained model
music_vae = TrainedModel(
      configs.CONFIG_MAP['cat-mel_2bar_big'], 
      batch_size=4, 
      checkpoint_dir_or_path='/content/mel_2bar_big.ckpt')

# Print statement informing user that the program has finished
# Initializing the Music VAE model
print('ðŸŽ‰ Done!')

# Generated and rendering the Music VAE model
generated_sequences = music_vae.sample(n=2, length=80, temperature=1.0)

# A for loop to generate the AI created notes that will be placed
# using the Music VAE model
for ns in generated_sequences:
  # print(ns)
  # This is a colab utility method that visualizes the NoteSequence
  # For the AI notes created via Music VAE.
  mm.plot_sequence(ns)
  # This is a colab utility method that plays the NoteSequence.
  # For the AI notes created via Music VAE.
  mm.play_sequence(ns, synth=mm.fluidsynth)

# Now it is time to fully combine and render
# Twinkle Twinkle Little Star song and
# Teapot song
# and the AI composed notes via the Music VAE model

# The amount of sequences, including the start and end ones, to generate.
num_steps = 8;

# The list of sequence and it's length.
note_sequences = music_vae.interpolate(
    teapot, # twinkle_twinkle
    twinkle_twinkle, #teapot
    num_steps=num_steps,
    length=32)

# Concatenate into one long sequence, with the start and
# end sequences at each end.
interp_seq = mm.sequences_lib.concatenate_sequences(note_sequences)

# This is a colab utility method that plays the NoteSequence
# For the fully composed AI music via the Music VAE model
mm.play_sequence(interp_seq, synth=mm.fluidsynth)

# This is a colab utility method that visualizes the NoteSequence
# For the fully composed AI music via the Music VAE model
mm.plot_sequence(interp_seq)

# This creates a file called `drums_sample_output.mid`, containing the drums solo we've been using.
mm.sequence_proto_to_midi_file(interp_seq, 'interp_seq_sample_output.mid')

# This is a colab utility method to download that file. In your Python script, you 
# would just write it to disk.
files.download('interp_seq_sample_output.mid')